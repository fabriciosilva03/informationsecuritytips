##   Dev Exploitation: Assembly para Pentesters - Linux

## Programando Assembly no Linux x86

Manual syscall via terminal

`man syscall`

`nano /usr/include/x86_64-linux-gnu/asm/`

`nano /usr/include/x86_64-linux-gnu/asm/unistd_32.h`


teste01.asm

```
global _main

section .data
  curso: db 'Security' ,0xa

section .text

_main:
  mov eax, 4
  mov ebx, 1
  mov ecx, curso
  mov edx, 15
  int 0x80
  
  mov eax, 1
  mov ebx, 0
  int 0x80
```

`nasm -f elf32 teste01.asm`

`ld --entry _main -m elf_i386 teste01.o -o teste01`

`./teste01`




## Debugando código criado em Assembly x86

Tool: GDB

`gdb ./teste01`




## Debugando com GDB TUI

Tool: GDB TUI

`gdb -q ./teste01 -tui `




## Debugger gráfico no Linux

`edb --run desec`




## Programando Assembly no Linux x64

`nano /usr/include/x86_64-linux-gnu/asm/unistd_64.h`

teste02.asm

```
global _main

section .data
  curso: db 'Security' ,0xa

section .text

_main:
  mov rax, 4
  mov rdi, 1
  mov rsi, curso
  mov rdx, 15
  syscall
  
  mov rax, 60
  mov rdi, 0
  syscall
  
```

`nasm -f elf64 teste02.asm`

`ld --entry _main -m teste02.o -o teste02`

`./teste02`

## Debugando código criado em Assembly x64

## Monitorando Syscalls

`apt install strace ltrace`

`strace ./teste01`

analisando o tamanho do arquivo

`du -h teste01`

analisando as chamadas do arquivo

`ldd programa`

Desassembly

`objdump -d -M intel teste01.o`

Analisando todas as chamadas de syscall

`ltrace ./teste01`

`ltrace -S ./teste01`












**Referência:** 

https://syscalls.w3challs.com/?arch=x86

]https://syscalls.w3challs.com/?arch=x86_64
